# -*- coding: utf-8 -*-
"""image-processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qCPPPt0vpb9T5taJiDv0RbxxLpXENFFL

Aout me: My name is  Mohamed Touati I'm Data scientist ,AI Research Engineer | Deep Learning and Computer Vision PhD Student. for any request you can contact me in my Linkedin profile : https://www.linkedin.com/in/mohamed-touati-enit/

Computer Vision now is  is one of the main technologies that enables the digital world to interact with the physical world.

# Image Processing with Python

In this notebook we wiil learn how to deal with image , work with python for image processing ,understand data types , manipulate and prepare images for analysis such as segmentation ... 

**Principals libraries:**

- SKIMAGE
- OPENCV
- MAHOTAS
-MATPLOTLIB

## Importing packages
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline 
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import skimage
from skimage import data

"""## Load Image 


**load an example image from skimage**
"""

camera=data.camera()
camera

type(camera)

camera.shape

#display image 
plt.imshow(camera,'gray')

#information about our image 
print("image shape array %d x %d "%(camera.shape[0],camera.shape[1]))
print('Number of pixels %d'%(camera.size))
print('Range of pixel: [%d ,%d]'%(camera.min(), camera.max()))
print('avg pixel value: %2f'%(camera.mean()))

"""**load your own image**"""

# mout the drive 
from google.colab import drive
drive.mount('/content/drive')

#  the directory where i'm working 
cd /content/drive/My Drive/Tutorial_python_medtouati/Image-processing

from skimage import io
colony=io.imread('Yeast_colonies_array.jpg')
print(type(colony)) # colony.type
print(colony.shape)

plt.figure(figsize=(10,10))
#all channels 
plt.subplot(121) # rows| columns | num pf sub images
plt.imshow(colony[:,:,:]) # or we just write io.imshow(colony)
plt.title('All 3 channels ')
#one channel
plt.subplot(122)
plt.imshow(colony[:,:,0]) 
plt.title('1-channel')

"""## Image Manipulation

###  Getting and Setting pixel values
"""

# get the value of pixel in row 10 column 10 
camera=data.camera()
camera[10,10]
plt.imshow(camera,"gray")

# set the value of pixels between  row 200 to 400 and column 120 to 130  to white
camera[200:400,120:130]=255
plt.imshow(camera,'gray')

# set the first 30 lines to black 
camera[:30]=10
plt.imshow(camera,'gray')

# set to white pixels where a mask(threshold) is true
camera=data.camera()
mask=camera<87
camera[mask]=255
plt.imshow(camera,"gray")

# change colours for real images
cat=data.chelsea()
print(type(cat))
print(cat.shape)
plt.imshow(cat)

# set a pixel to green
# [red,green,blue]
cat[50:60,70:80]=[0,255,0]
plt.imshow(cat)

# set brighter pixels to red 
cat=data.chelsea()
red_cat=cat.copy()
reedish=cat[:,:,0]>160  # 0 for R channel , 1 for G channel and 2 for B channel
red_cat[reedish]=[255,0,0]  # 255 intensity fo pixels  for Red channel 
plt.imshow(red_cat)

# set brighter pixels to green 
cat=data.chelsea()
red_cat=cat.copy()
reedish=cat[:,:,0]>160
red_cat[reedish]=[0,255,0]
plt.imshow(red_cat)

#change RGB to BGR (for opencv)
cat=data.chelsea() # inset the cat image with skimage in RGB 
# we playing on color space with changing the value of channels from 0 to 2 
BGR_cat=cat[:,:,::-1] # [x pixels, y pixels , channels inverted ] so we get BGR    
plt.imshow(BGR_cat)  # display the BGR_cat image

# invert an image 
from skimage import util # Invert the intensity range of the input image, 
invert_cat=util.invert(cat)
plt.imshow(invert_cat)
#so that the dtype maximum is now the dtype minimum, and vice-versa

"""we playing with the data that is in the image as apposed to swapping around the ratios so it's a difference between the ration of colors versus the actual intensity of each of the colors"""

# convert to and  from RBG 
from skimage.color import rgb2gray, gray2rgb
graycat=rgb2gray(cat)
newcat=gray2rgb(graycat)
plt.imshow(graycat)
plt.imshow(newcat)

"""### converting Image dtype

`img_as_float`  
 Convert to 64-bit floating point.

---
`img_as_ubyte`     
 Convert to 8-bit uint.

---

`img_as_uint`       
Convert to 16-bit uint.

---

`img_as_int`          
        Convert to 16-bit int.
"""

from skimage import img_as_float ,img_as_ubyte 
float_cat=img_as_float(cat)  #  Convert to 64-bit floating point.
uint_cat=img_as_ubyte(float_cat)   #  Convert to 8-bit uint.
plt.imshow(uint_cat) # the same image as cat with a different type

"""### Rescale Intensity"""

from skimage  import exposure 
rescale_cat=exposure.rescale_intensity(cat,in_range="uint8") 
print("cat min:",cat.min(),"\t\tcat max:",cat.max())
print("rescale_cat min:",rescale_cat.min(),"\trescale_cat max:",rescale_cat.max())

rescale_cat=exposure.rescale_intensity(cat,in_range="uint10") 
print("cat min:",cat.min(),"\t\tcat max:",cat.max())
print("rescale_cat min:",rescale_cat.min(),"\trescale_cat max:",rescale_cat.max())

plt.imshow(rescale_cat)

"""### Display Image histograms"""

img =data.camera()
plt.hist(img.ravel(), bins=None) # histtype='step' #color='blue'

img =data.camera()
plt.hist(img.ravel(), bins=256,histtype='step')

"""### Image Segmentation"""

# use colony image 
colony=io.imread('Yeast_colonies_array.jpg')
plt.imshow(colony)

# let's convert our iamge to gray 
from skimage.color import rgb2gray, gray2rgb
gray_colony=rgb2gray(colony)
plt.hist(gray_colony.ravel(), bins=256,histtype='step')

# use the threshold 
plt.figure(figsize=(20,30))

plt.subplot(131)
plt.imshow(colony)
plt.title('colony')

plt.subplot(132)
plt.imshow(gray_colony)
plt.title('gray_colony')

plt.subplot(133)
plt.imshow(gray_colony>0.5) # threshold betweek 0 and 1 cause gray_colony values  are in [0,1]
plt.title('gray_colony with threshold') # we see much better our object

"""#### Edge detector"""

# we can use the detection high contrast regions 
from skimage.feature import canny
img_edge=canny(img)
plt.imshow(img_edge)

import  scipy.ndimage as ndi
img_edge=canny(img)
img_filled=ndi.binary_fill_holes(img_edge)

plt.figure(figsize=(20,10))
plt.subplot(121)
plt.imshow(img_edge,"gray")
plt.subplot(122)
plt.imshow(img_filled,"gray")

# canny edge detector on cat
from skimage.feature import canny
import  scipy.ndimage as ndi
cat =data.chelsea()
img_edges_cat=canny(cat[:,:,0]/255.)  # 0 to 1 value 
img_filled_cat=ndi.binary_fill_holes(img_edges_cat)
plt.figure(figsize=(24,18))
plt.subplot(121)
plt.title("img_edges_cat")
plt.imshow(img_edges_cat,"gray")
plt.subplot(122)
plt.imshow(img_filled_cat,"gray")
plt.title('img_filled_cat')

"""#### Watershed Algorithm"""

from skimage.filters import sobel 
from skimage.morphology import watershed
#evaluation map 
evaluation_map=sobel(gray_colony) #gray_colony is 2dim array however colony is a 3 dim array 
plt.figure(figsize=(24,18))
plt.subplot(121)
plt.imshow(gray_colony,"gray")
plt.subplot(122)
plt.imshow(evaluation_map,'gray')

# Separate pixels into 3 classes 
# algorithms uses user define markers 
markers=np.zeros_like(gray_colony)
markers[gray_colony<0.30]=1
markers[gray_colony>0.60]=2
plt.imshow(markers) 
# in tis image we create a new markers and  we made it in the shape of our image
#we plotted in one markers yellow all the ones that are below between 0.30 for those whaite and black 
 #there is middles class between 0.30 and 0.55 
 #and then into above class above 0.60  that's corresponds to like the dark blue , the green blue and the yellow 
 #we can use our watershed , sobel and markers to segment

# Segmentation with watershed transform
segmentation=watershed(evaluation_map,markers)
# set backgroud pixels to 0 
segmentation[segmentation==0]=0
plt.imshow(segmentation,'gray')
# we're feeding it  ,the evaluation map

"""#### label semgentation object"""

#label segmentation  obejcts 
label_colony, number =ndi.label(gray_colony)
print(number)
plt.imshow(label_colony)

